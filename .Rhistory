french_fries = na.omit(french_fries)
# input data
x = french_fries$potato
y = french_fries$buttery
# space along which to smooth
z = seq(0, 15, length.out = 100)
# run smoothing
fits = llr(z = z, x = x, y = y, omega = 2)
# plot the data and the smoother
plot(x, y)
lines(z, fits, col = 'red')
# run smoothing
fits = llr(z = z, x = x, y = y, omega = 5)
# plot the data and the smoother
plot(x, y)
lines(z, fits, col = 'red')
# run smoothing
fits = llr(z = z, x = x, y = y, omega = 10)
# plot the data and the smoother
plot(x, y)
lines(z, fits, col = 'red')
# run smoothing
fits = llr(z = z, x = x, y = y, omega = 1000)
# plot the data and the smoother
plot(x, y)
lines(z, fits, col = 'red')
# load package functions and functions we want to test
library(testthat)
import::here(compute_f_hat, llr, make_predictor_matrix, make_weight_matrix, W,
.from = 'llr_functions.R')
context("Check local linear regression function")
# generate data for a very simple regression model
n = 15
x = rnorm(n)
y = rnorm(x + rnorm(n))
z = seq(-1, 1, length.out = 100)
omega = 1
test_that("llr output has correct length", {
expect_equal(length(llr(x, y, z, omega = 1)), length(z))
})
test_that("make_weight_matrix works on simple cases", {
# make an example weight matrix
Wz = make_weight_matrix(z[1], x, omega)
# check that the output is a diagonal matrix,
expect_true(all(c(Wz[upper.tri(Wz)], Wz[lower.tri(Wz)]) == 0))
# that all the elements are nonnegative,
expect_true(all(Wz >= 0))
# that the weights are correct in simple cases
# where you know what the output should be
r = abs(x - z[1]) / omega
expect_equal(diag(Wz), sapply(r, W))
})
test_that("make_predictor_matrix works on simple cases", {
# make an example predictor matrix
X = make_predictor_matrix(x)
# write tests to check that the dimensions are correct,
expect_equal(dim(X), c(n, 2))
# the first column is all 1's,
expect_equal(X[, 1], rep(1, n))
# second column is x
expect_equal(X[, 2], x)
})
# STAT-S 610
# LAB 4
# 2019-10-03
# https://jfukuyama.github.io/teaching/stat610/assignments/lab4.pdf
# TO RUN:
testthat::test_dir('.')
data(french_fries)
french_fries = french_fries[complete.cases(french_fries),]
llr = function(x, y, z, omega) {
fits = sapply(z, compute_f_hat, x, y, omega)
return(fits)
}
compute_f_hat = function(z, x, y, omega) {
Wz = make_weight_matrix(z, x, omega)
X = make_predictor_matrix(x)
f_hat = c(1, z) %*% solve(t(X) %*% Wz %*% X) %*% t(X) %*% Wz %*% y
return(f_hat)
}
make_weight_matrix = function(z, x, omega) {
r = abs(x - z) / omega  # this is a vector of the same length as x
w = sapply(r, W)  # this is a vector of the same length as x and r
Wz = diag(w)  # this is a diagonal matrix with elements from w
return(Wz)
}
W = function(r) {
if (abs(r) < 1) {
return((1 - abs(r) ** 3) ** 3)
} else {
return(0)
}
}
make_predictor_matrix = function(x){
ones = rep(1, times = length(x))
return(matrix(c(ones,x), nrow = length(x), ncol = 2, byrow = FALSE))
}
library(reshape2)
data(french_fries)
french_fries = french_fries[complete.cases(french_fries),]
z = seq(0, 15, length.out = 100)
fits = llr(z = z, x = french_fries$potato, y = french_fries$buttery, omega = 2000)
plot(z, fits)
fits = llr(z = z, x = french_fries$potato, y = french_fries$buttery, omega = 20)
plot(x, y)
lines(z, fits, col = 'red')
library(reshape2)
data(french_fries)
french_fries = french_fries[complete.cases(french_fries),]
z = seq(0, 15, length.out = 100)
fits = llr(z = z, x = french_fries$potato, y = french_fries$buttery, omega = 20)
plot(x, y)
plot(french_fries$potato, french_fries$buttery)
lines(z, fits, col = 'red')
fits = llr(z = z, x = french_fries$potato, y = french_fries$buttery, omega = 2)
plot(french_fries$potato, french_fries$buttery)
lines(z, fits, col = 'red')
fits = llr(z = z, x = french_fries$potato, y = french_fries$buttery, omega = 200)
plot(french_fries$potato, french_fries$buttery)
lines(z, fits, col = 'red')
# STAT-S 610
# LAB 4
# 2019-10-03
# https://jfukuyama.github.io/teaching/stat610/assignments/lab4.pdf
# TO RUN:
testthat::test_dir('.')
getwd
getwd()
dir()
# load package functions and functions we want to test
library(testthat)
import::here(compute_f_hat, llr, make_predictor_matrix, make_weight_matrix, W,
.from = 'llr_functions.R')
context("Check local linear regression function")
# generate data for a very simple regression model
n = 15
x = rnorm(n)
y = rnorm(x + rnorm(n))
z = seq(-1, 1, length.out = 100)
omega = 1
test_that("llr output has correct length", {
expect_equal(length(llr(x, y, z, omega = 1)), length(z))
})
test_that("make_weight_matrix works on simple cases", {
# make an example weight matrix
Wz = make_weight_matrix(z[1], x, omega)
# check that the output is a diagonal matrix,
expect_true(all(c(Wz[upper.tri(Wz)], Wz[lower.tri(Wz)]) == 0))
# that all the elements are nonnegative,
expect_true(all(Wz >= 0))
# that the weights are correct in simple cases
# where you know what the output should be
r = abs(x - z[1]) / omega
expect_equal(diag(Wz), sapply(r, W))
})
test_that("make_predictor_matrix works on simple cases", {
# make an example predictor matrix
X = make_predictor_matrix(x)
# write tests to check that the dimensions are correct,
expect_equal(dim(X), c(n, 2))
# the first column is all 1's,
expect_equal(X[, 1], rep(1, n))
# second column is x
expect_equal(X[, 2], x)
})
# STAT-S 610
# LAB 4
# 2019-10-03
# https://jfukuyama.github.io/teaching/stat610/assignments/lab4.pdf
# TO RUN:
testthat::test_dir('.')
llr = function(x, y, z, omega) {
fits = sapply(z, compute_f_hat, x, y, omega)
return(fits)
}
compute_f_hat = function(z, x, y, omega) {
Wz = make_weight_matrix(z, x, omega)
X = make_predictor_matrix(x)
f_hat = c(1, z) %*% solve(t(X) %*% Wz %*% X) %*% t(X) %*% Wz %*% y
return(f_hat)
}
make_weight_matrix = function(z, x, omega) {
r = abs(x - z) / omega  # this is a vector of the same length as x
w = sapply(r, W)  # this is a vector of the same length as x and r
Wz = diag(w)  # this is a diagonal matrix with elements from w
return(Wz)
}
W = function(r) {
if (abs(r) < 1) {
return((1 - abs(r) ** 3) ** 3)
} else {
return(0)
}
}
make_predictor_matrix = function(x){
ones = rep(1, times = length(x))
return(matrix(c(ones,x), nrow = length(x), ncol = 2, byrow = FALSE))
}
library(reshape2)
data(french_fries)
french_fries = french_fries[complete.cases(french_fries),]
z = seq(0, 15, length.out = 100)
fits = llr(z = z, x = french_fries$potato, y = french_fries$buttery, omega = 200)
plot(french_fries$potato, french_fries$buttery)
lines(z, fits, col = 'red')
# load package functions and functions we want to test
library(testthat)
import::here(compute_f_hat, llr, make_predictor_matrix, make_weight_matrix, W,
.from = 'llr_functions.R')
context("Check local linear regression function")
# generate data for a very simple regression model
n = 15
x = rnorm(n)
y = rnorm(x + rnorm(n))
z = seq(-1, 1, length.out = 100)
omega = 1
test_that("llr output has correct length", {
expect_equal(length(llr(x, y, z, omega = 1)), length(z))
})
test_that("make_weight_matrix works on simple cases", {
# make an example weight matrix
Wz = make_weight_matrix(z[1], x, omega)
# check that the output is a diagonal matrix,
expect_true(all(c(Wz[upper.tri(Wz)], Wz[lower.tri(Wz)]) == 0))
# that all the elements are nonnegative,
expect_true(all(Wz >= 0))
# that the weights are correct in simple cases
# where you know what the output should be
r = abs(x - z[1]) / omega
expect_equal(diag(Wz), sapply(r, W))
})
test_that("make_predictor_matrix works on simple cases", {
# make an example predictor matrix
X = make_predictor_matrix(x)
# write tests to check that the dimensions are correct,
expect_equal(dim(X), c(n, 2))
# the first column is all 1's,
expect_equal(X[, 1], rep(1, n))
# second column is x
expect_equal(X[, 2], x)
})
# STAT-S 610
# LAB 4
# 2019-10-03
# https://jfukuyama.github.io/teaching/stat610/assignments/lab4.pdf
# TO RUN:
testthat::test_dir('.')
# STAT-S 610
# LAB 4
# 2019-10-03
# https://jfukuyama.github.io/teaching/stat610/assignments/lab4.pdf
# TO RUN:
testthat::test_dir('.')
# STAT-S 610
# LAB 4
# 2019-10-03
# https://jfukuyama.github.io/teaching/stat610/assignments/lab4.pdf
# TO RUN:
testthat::test_dir('.')
llr = function(x, y, z, omega) {
fits = sapply(z, compute_f_hat, x, y, omega)
return(fits)
}
compute_f_hat = function(z, x, y, omega) {
Wz = make_weight_matrix(z, x, omega)
X = make_predictor_matrix(x)
f_hat = c(1, z) %*% solve(t(X) %*% Wz %*% X) %*% t(X) %*% Wz %*% y
return(f_hat)
}
make_weight_matrix = function(z, x, omega) {
r = abs(x - z) / omega  # this is a vector of the same length as x
w = sapply(r, W)  # this is a vector of the same length as x and r
Wz = diag(w)  # this is a diagonal matrix with elements from w
return(Wz)
}
W = function(r) {
if (abs(r) < 1) {
return((1 - abs(r) ** 3) ** 3)
} else {
return(0)
}
}
make_predictor_matrix = function(x){
ones = rep(1, times = length(x))
return(matrix(c(ones,x), nrow = length(x), ncol = 2, byrow = FALSE))
}
library(reshape2)
data(french_fries)
french_fries = french_fries[complete.cases(french_fries),]
z = seq(0, 15, length.out = 100)
fits = llr(z = z, x = french_fries$potato, y = french_fries$buttery, omega = 200)
plot(french_fries$potato, french_fries$buttery)
lines(z, fits, col = 'red')
# load package functions and functions we want to test
library(testthat)
import::here(compute_f_hat, llr, make_predictor_matrix, make_weight_matrix, W,
.from = 'llr_functions.R')
context("Check local linear regression function")
# generate data for a very simple regression model
n = 15
# generate data for a very simple regression model
n = 15
x = rnorm(n)
y = rnorm(x + rnorm(n))
z = seq(-1, 1, length.out = 100)
omega = 1
test_that("llr output has correct length", {
expect_equal(length(llr(x, y, z, omega = 1)), length(z))
})
test_that("make_weight_matrix works on simple cases", {
# make an example weight matrix
Wz = make_weight_matrix(z[1], x, omega)
# check that the output is a diagonal matrix,
expect_true(all(c(Wz[upper.tri(Wz)], Wz[lower.tri(Wz)]) == 0))
# that all the elements are nonnegative,
expect_true(all(Wz >= 0))
# that the weights are correct in simple cases
# where you know what the output should be
r = abs(x - z[1]) / omega
expect_equal(diag(Wz), sapply(r, W))
})
test_that("make_predictor_matrix works on simple cases", {
# make an example predictor matrix
X = make_predictor_matrix(x)
# write tests to check that the dimensions are correct,
expect_equal(dim(X), c(n, 2))
# the first column is all 1's,
expect_equal(X[, 1], rep(1, n))
# second column is x
expect_equal(X[, 2], x)
})
# STAT-S 610
# LAB 4
# 2019-10-03
# https://jfukuyama.github.io/teaching/stat610/assignments/lab4.pdf
# TO RUN:
testthat::test_dir('.')
getwd()
source('~/Downloads/homework5-610/llr_functions.R', echo=TRUE)
setwd("/Users/azakeres/Downloads/homework5-610")
llr = function(x, y, z, omega) {
fits = sapply(z, compute_f_hat, x, y, omega)
return(fits)
}
compute_f_hat = function(z, x, y, omega) {
Wz = make_weight_matrix(z, x, omega)
X = make_predictor_matrix(x)
f_hat = c(1, z) %*% solve(t(X) %*% Wz %*% X) %*% t(X) %*% Wz %*% y
return(f_hat)
}
make_weight_matrix = function(z, x, omega) {
r = abs(x - z) / omega  # this is a vector of the same length as x
w = sapply(r, W)  # this is a vector of the same length as x and r
Wz = diag(w)  # this is a diagonal matrix with elements from w
return(Wz)
}
W = function(r) {
if (abs(r) < 1) {
return((1 - abs(r) ** 3) ** 3)
} else {
return(0)
}
}
make_predictor_matrix = function(x){
ones = rep(1, times = length(x))
return(matrix(c(ones,x), nrow = length(x), ncol = 2, byrow = FALSE))
}
library(reshape2)
data(french_fries)
french_fries = french_fries[complete.cases(french_fries),]
z = seq(0, 15, length.out = 100)
fits = llr(z = z, x = french_fries$potato, y = french_fries$buttery, omega = 200)
plot(french_fries$potato, french_fries$buttery)
lines(z, fits, col = 'red')
# STAT-S 610
# LAB 4
# 2019-10-03
# https://jfukuyama.github.io/teaching/stat610/assignments/lab4.pdf
# TO RUN:
testthat::test_dir('.')
# load package functions and functions we want to test
library(testthat)
import::here(compute_f_hat, llr, make_predictor_matrix, make_weight_matrix, W,
.from = 'llr_functions.R')
context("Check local linear regression function")
# generate data for a very simple regression model
n = 15
x = rnorm(n)
y = rnorm(x + rnorm(n))
z = seq(-1, 1, length.out = 100)
omega = 1
test_that("llr output has correct length", {
expect_equal(length(llr(x, y, z, omega = 1)), length(z))
})
test_that("make_weight_matrix works on simple cases", {
# make an example weight matrix
Wz = make_weight_matrix(z[1], x, omega)
# check that the output is a diagonal matrix,
expect_true(all(c(Wz[upper.tri(Wz)], Wz[lower.tri(Wz)]) == 0))
# that all the elements are nonnegative,
expect_true(all(Wz >= 0))
# that the weights are correct in simple cases
# where you know what the output should be
r = abs(x - z[1]) / omega
expect_equal(diag(Wz), sapply(r, W))
})
test_that("make_predictor_matrix works on simple cases", {
# make an example predictor matrix
X = make_predictor_matrix(x)
# write tests to check that the dimensions are correct,
expect_equal(dim(X), c(n, 2))
# the first column is all 1's,
expect_equal(X[, 1], rep(1, n))
# second column is x
expect_equal(X[, 2], x)
})
# STAT-S 610
# LAB 4
# 2019-10-03
# https://jfukuyama.github.io/teaching/stat610/assignments/lab4.pdf
# TO RUN:
testthat::test_dir('.')
llr = function(x, y, z, omega) {
fits = sapply(z, compute_f_hat, x, y, omega)
return(fits)
}
# STAT-S 610
# LAB 4
# 2019-10-03
# https://jfukuyama.github.io/teaching/stat610/assignments/lab4.pdf
# TO RUN:
testthat::test_dir('.')
# STAT-S 610
# LAB 4
# 2019-10-03
# https://jfukuyama.github.io/teaching/stat610/assignments/lab4.pdf
# TO RUN:
testthat::test_dir('.')
dir()
import::here(compute_f_hat, llr, make_predictor_matrix, make_weight_matrix, W,
.from = 'llr_functions.R')
test_that("llr output has correct length", {
expect_equal(length(llr(x, y, z, omega = 1)), length(z))
})
#' @param x (numeric) vector of same length as y
#' @param y (numeric) vector of same length as y
#' @param z (numeric) vector, can be of a different length
#' @param omega (numeric) must be a scalar
#' @return (numeric) vector of the same length as z
llr = function(x, y, z, omega) {
fits = sapply(z, compute_f_hat, x, y, omega)
return(fits)
}
#' @param z (numeric) must be a scalar
#' @param x (numeric) vector of the same length as y
#' @param y (numeric) vector of the same length as x
#' @param omega (numeric) must be a scalar
#' @return (numeric) scalar
compute_f_hat = function(z, x, y, omega) {
Wz = make_weight_matrix(z, x, omega)
X = make_predictor_matrix(x)
f_hat = c(1, z) %*% solve(t(X) %*% Wz %*% X) %*% t(X) %*% Wz %*% y
return(f_hat)
}
#' @param z (numeric) must be a scalar
#' @param x (numeric) vector of arbitrary length
#' @param omega (numeric) must be a scalar
#' @return (numeric) a diagonal matrix
make_weight_matrix = function(z, x, omega) {
r = abs(x - z) / omega  # this is a vector of the same length as x
w = sapply(r, W)  # this is a vector of the same length as x and r
Wz = diag(w)  # this is a diagonal matrix with elements from w
return(Wz)
}
#' @param r (numeric) must be a scalar
#' @return (numeric) scalar
W = function(r) {
if (abs(r) < 1) {
return((1 - abs(r) ** 3) ** 3)
} else {
return(0)
}
}
#' @param x (numeric) vector of arbitrary length
#' @return (numeric) matrix with 2 columns and rows equal to length of x
make_predictor_matrix = function(x) {
n = length(x)
return(cbind(rep(1, n), x))
}
# get the data
data(french_fries, package = 'reshape2')
french_fries = na.omit(french_fries)
# input data
x = french_fries$potato
y = french_fries$buttery
# space along which to smooth
z = seq(0, 15, length.out = 100)
# run smoothing
fits = llr(z = z, x = x, y = y, omega = 2)
# plot the data and the smoother
plot(x, y)
lines(z, fits, col = 'red')
# noisy sine wave
x = runif(1000, -2 * pi, 2 * pi)
y = sin(x) + rnorm(length(x))
# space along which to smooth
z = seq(-2 * pi, 2 * pi, length.out = 100)
# run smoothing
fits = llr(z = z, x = x, y = y, omega = pi / 3)
# plot the data and the smoother
plot(x, y)
lines(z, fits, col = 'red')
